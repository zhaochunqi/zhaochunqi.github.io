<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="theme-color" content="#f8f5ec"><meta name="msapplication-navbutton-color" content="#f8f5ec"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec"><meta name="description" content="Java Lambda 表达式（又名闭包 (Closure)/ 匿名函数 ) 笔记"><meta name="keywords" content="java, Alex Coding"><link rel="alternate" href="/atom.xml" title="Alex Coding"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0"><link rel="canonical" href="http://blog.zhaochunqi.com/2016/11/15/java_lambda_expressions/"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0"><script id="baidu_analytics">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?cfffa20d202ba9f4f0d6257e1cc94ea6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script id="google_analytics">!function(e,a,t,n,c,g,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,g=a.createElement("script"),o=a.getElementsByTagName("script")[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(g,o)}(window,document),ga("create","UA-42448552-1","auto"),ga("send","pageview")</script><script id="baidu_push">!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script><script id="leancloud">AV.init({appId:"YECzMLE9UTvajIqEbA5NK8wN-gzGzoHsz",appKey:"vK6VPlmNULOlnr5q6CFvqozN"})</script><title>Java Lambda 表达式（又名闭包 (Closure)/ 匿名函数 ) 笔记 - Alex Coding</title></head><body><div id="mobile-navbar" class="mobile-navbar"><div class="mobile-header-logo"><a href="/." class="logo">Alex Coding</a></div><div class="mobile-navbar-icon"><span></span> <span></span> <span></span></div></div><nav id="mobile-menu" class="mobile-menu slideout-menu"><ul class="mobile-menu-list"><a href="/"><li class="mobile-menu-item">首页</li></a><a href="/archives/"><li class="mobile-menu-item">归档</li></a></ul></nav><div class="container" id="mobile-panel"><header id="header" class="header"><div class="logo-wrapper"><a href="/." class="logo">Alex Coding</a></div><nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item"><a class="menu-item-link" href="/">首页</a></li><li class="menu-item"><a class="menu-item-link" href="/archives/">归档</a></li></ul></nav></header><main id="main" class="main"><div class="content-wrapper"><div id="content" class="content"><article class="post"><header class="post-header"><h1 class="post-title">Java Lambda 表达式（又名闭包 (Closure)/ 匿名函数 ) 笔记</h1><div class="post-meta"><span class="post-time">2016-11-15</span><div class="post-category"><a href="/categories/java/">java</a></div><div class="post-visits" data-url="/2016/11/15/java_lambda_expressions/" data-title="Java Lambda 表达式（又名闭包 (Closure)/ 匿名函数 ) 笔记">阅读次数</div></div></header><div class="post-toc" id="post-toc"><h2 class="post-toc-title">文章目录</h2><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSR-335"><span class="toc-text">JSR 335</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要 -Lambda- 表达式"><span class="toc-text">为什么需要 Lambda 表达式?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原来怎么处理"><span class="toc-text">原来怎么处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子一"><span class="toc-text">例子一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子二"><span class="toc-text">例子二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子三"><span class="toc-text">例子三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上面代码有什么问题呢？"><span class="toc-text">上面代码有什么问题呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda- 表达式语法 -Syntax"><span class="toc-text">Lambda 表达式语法(Syntax)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多返回值"><span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无参数"><span class="toc-text">无参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#省略"><span class="toc-text">省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修饰符"><span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意"><span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式接口 -Functional-Interfaces-SAM"><span class="toc-text">函数式接口(Functional Interfaces/SAM)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparable"><span class="toc-text">Comparable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnClickListener"><span class="toc-text">OnClickListener</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method-References"><span class="toc-text">Method References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法引用 -Constructor-References"><span class="toc-text">构造方法引用 Constructor References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量作用域"><span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Default-Methods"><span class="toc-text">Default Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Methods-in-Interfaces"><span class="toc-text">Static Methods in Interfaces</span></a></li></ol></div></div><div class="post-content"><p>根据 <a href="https://jcp.org/en/jsr/detail?id=335" target="_blank" rel="noopener">JSR 335</a>, Java 终于在 Java 8 中引入了 Lambda 表达式。也称之为闭包或者匿名函数。</p><a id="more"></a><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1flzgw9sbtfj30jg08ct8r.jpg" alt="http://harchiko.qiniudn.com/Lambda%20Expression%20Java%208.png"></p><h2 id="JSR-335"><a href="#JSR-335" class="headerlink" title="JSR 335"></a>JSR 335</h2><p>所谓的 JSR （Java Specification Requests） 全称叫做 Java 规范提案。简单来说就是向 Java 社区提交新的 API 或 服务 请求的提案。这些提案将作为 Java 社区进行 Java 语言开发的需求，引导着开发的方向。</p><p>JSR 335 的提案内容摘要如下：</p><blockquote><p>This JSR will extend the Java Programming Language Specification and the Java Virtual Machine Specification to support the following features:</p><ul><li>Lambda Expressions</li><li>SAM Conversion</li><li>Method References</li><li>Virtual Extension Methods</li></ul></blockquote><p>也就是如下几点：</p><ol><li>支持 lambda 表达式。</li><li>支持 SAM conversion 用来向前兼容。</li><li>方法引用 Method References</li><li>Virtual Extension Methods</li></ol><p>在 Java 8 中，以上均已经实现, 以上内容下文均有介绍。</p><h2 id="为什么需要 -Lambda- 表达式"><a href="# 为什么需要 -Lambda- 表达式" class="headerlink" title="为什么需要 Lambda 表达式?"></a>为什么需要 Lambda 表达式?</h2><p>Lambda 表达式，其实就是代码块。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1flzgwbdd9ij308l06v0st.jpg" alt="http://harchiko.qiniudn.com/56cabf5a499ed708%202.jpg"></p><h3 id="原来怎么处理"><a href="# 原来怎么处理" class="headerlink" title="原来怎么处理"></a>原来怎么处理</h3><p>在具体了解 lambda 之前，我们先往后退一步，看看之前我们是如何处理这些代码块的！</p><h4 id="例子一"><a href="# 例子一" class="headerlink" title="例子一"></a>例子一</h4><p>当决定在单独的线程运行某程序时，你这样做的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">           doWork();</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这样执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker w = <span class="keyword">new</span> Worker();</span><br><span class="line"><span class="keyword">new</span> Thread(w).start();</span><br></pre></td></tr></table></figure>
<p>Worker 中包含了你要执行的代码块。</p>
<h4 id="例子二"><a href="# 例子二" class="headerlink" title="例子二"></a>例子二 </h4><p> 如果你想实现根据字符串长度大小来排序，而不是默认的字母顺序，你可以自己来实现一个  Comparator 用来 Sort。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(first.length(), second.length());</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> LengthComparator());</span><br></pre></td></tr></table></figure>
<h4 id="例子三"><a href="# 例子三" class="headerlink" title="例子三"></a>例子三 </h4><p> 另外一个例子，我选的是 Android 中的点击事件，同样是 Java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Hello World!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="上面代码有什么问题呢？"><a href="# 上面代码有什么问题呢？" class="headerlink" title="上面代码有什么问题呢？"></a>上面代码有什么问题呢？</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1flzgwdq0rwj30hs0d4q30.jpg" alt="http://harchiko.qiniudn.com/c718cee7.jpg"></p>
<p>它们都太复杂了啊！</p>
<blockquote>
<p>上述例子都是在某个类中实现某个接口，然后传递到另外一个方法中作为参数，然后用来执行。</p>
</blockquote>
<p>但是本质上，他们要传递的就是接口中那一个方法的实现而已啊！有必要先创建类，再实例化，再传递给调用的位置吗？</p>
<blockquote>
<p>因为 Java 是纯面向对象的语言，像其他语言那样随随便便传个方法过来，那可不行，必须要这样。</p>
</blockquote>
<p>在其他语言中你可能可以，但是，在 Java 中，不可以。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1flzgwf5406j307t06vwej.jpg" alt="http://harchiko.qiniudn.com/56cabf7011ab6750.jpg"></p>
<p>Java 设计人员为了 Java 的简洁跟连贯性，一直拒绝为 Java 添加这种功能。（这也是我喜欢 Java 而不喜欢 Python 的原因啊！！！)</p>
<p>经过多年的努力，开发人员终于找到了符合 Java 编程习惯的 Lambda 表达式！</p>
<h2 id="Lambda- 表达式语法 -Syntax"><a href="#Lambda- 表达式语法 -Syntax" class="headerlink" title="Lambda 表达式语法 (Syntax)"></a>Lambda 表达式语法(Syntax)</h2><p> 考虑下前面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure>
<p>first 和 second 都是 String 类型，Java 是强类型的语言，必须指定类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">     -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1flzgwghv0jj30av0c6dg2.jpg" alt="http://harchiko.qiniudn.com/14365393725281065.jpg"></p>
<p>看到没有！第一个 Lambda 表达式诞生了！！输入、输出简洁明了！</p>
<blockquote>
<p>为什么叫 Lambda 呢，这个很多年以前，有位逻辑学家想要标准化的表示一些可以被计算的数学方程（实际上存在，但是很难被表示出来），他就用 ℷ 来表示。</p>
</blockquote>
<p>重新介绍一下 Java 中 Lambda 表达式的格式:</p>
<blockquote>
<p>(参数) -&gt; 表达式</p>
</blockquote>
<h3 id="多返回值"><a href="# 多返回值" class="headerlink" title="多返回值"></a>多返回值 </h3><p> 如果计算的结果并不由一个单一的表达式返回（换言之，返回值存在多种情况），使用“{}”，然后明确指定返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无参数"><a href="# 无参数" class="headerlink" title="无参数"></a>无参数 </h3><p> 如果没有参数，则 “()”中就空着。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) doWork(); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="省略"><a href="# 省略" class="headerlink" title="省略"></a>省略 </h3><p> 如果参数的类型可以被推断出，则可以直接省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp</span><br><span class="line">     = (first, second) <span class="comment">// Same as (String first, String second)</span></span><br><span class="line">        -&gt; Integer.compare(first.length(), second.length());</span><br></pre></td></tr></table></figure>
<p>这里，first 和 second 可以被推断出是 String 类型，因为 是一个 String 类型的 Comparator。</p>
<p>如果单个参数可以被推断出，你连括号都可以省略：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventHandler&lt;ActionEvent&gt; listener = event -&gt;</span><br><span class="line">     System.out.println(<span class="string">"Thanks for clicking!"</span>);</span><br><span class="line">        <span class="comment">// Instead of (event) -&gt; or (ActionEvent event) -&gt;</span></span><br></pre></td></tr></table></figure><p></p>
<h3 id="修饰符"><a href="# 修饰符" class="headerlink" title="修饰符"></a>修饰符 </h3><p> 你可以像对待其他方法一样，annotation，或者 使用 final 修饰符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">final</span> String name) -&gt; ...</span><br><span class="line">    (<span class="meta">@NonNull</span> String name) -&gt; ...</span><br></pre></td></tr></table></figure>
<p><strong>永远不要 </strong> 定义 result 的类型，lambda 表达式总是从上下文中推断出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; Integer.compare(first.length(), second.length())</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="# 注意" class="headerlink" title="注意"></a>注意 </h3><p> 注意，在 lambda 表达式中，某些分支存在返回值，某些不存在返回值这样的情况是不允许的。<br>如 <code>(int x) -&gt; {if (x &gt;= 0) return 1; }</code>这样是非法的。</p>
<h2 id="函数式接口 -Functional-Interfaces-SAM"><a href="# 函数式接口 -Functional-Interfaces-SAM" class="headerlink" title="函数式接口 (Functional Interfaces/SAM)"></a> 函数式接口(Functional Interfaces/SAM)</h2><blockquote>
<p>要介绍 Java 中 lambda 表达式的实现，需要知道什么是 函数式接口。</p>
</blockquote>
<p>什么叫作函数式接口呢(SAM)？</p>
<blockquote>
<p>函数式接口指的是只定义了唯一的抽象方法的接口（除了隐含的 Object 对象的公共方法）， 因此最开始也就做 SAM 类型的接口（Single Abstract Method）。</p>
</blockquote>
<p>Lambda 表达式 <strong> 向前兼容 </strong> 这些接口。</p>
<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>举个例子 Array.sort:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,</span><br><span class="line">     (first, second) -&gt; Integer.compare(first.length(), second.length()));</span><br></pre></td></tr></table></figure>
<p>Array.sort() 方法收到一个实现了 Comparable<string> 接口的实例。</string></p>
<p>其实可以把 Lambda 表达式想象成一个方法，而非一个对象，一个可以传入一个接口的方法。</p>
<h3 id="OnClickListener"><a href="#OnClickListener" class="headerlink" title="OnClickListener"></a>OnClickListener</h3><p>再举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(event -&gt;</span><br><span class="line">     System.out.println(<span class="string">"Thanks for clicking!"</span>));</span><br></pre></td></tr></table></figure>
<p>你看，是不是更易读了呢？</p>
<p>Lambda 表达式能够向前兼容这些 interfaces, 太棒了！ 那 Lambda 表达式还能干什么呢？</p>
<p>实际上，将函数式接口转变成 lambda 表达式是你在 Java 中 <strong> 唯一 </strong> 能做的事情。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1flzgwi9bdnj30er0ermyd.jpg" alt="http://harchiko.qiniudn.com/20150930185659_eMZyN.jpeg"></p>
<p>Why ？！！</p>
<p>在其他的语言中，你可以定义一些方便的方法类型，但在 Java 中，你甚至不能将一个 Lambda 表达式赋值给类型为 Object 的变量，因为 Object 变量不是一个 Functional Interface。</p>
<p>Java 的设计者们坚持使用熟悉的 interface 概念而不是为其引入新的 方法类型。</p>
<p>(这里我还要为设计者点赞！谨慎的设计，一方面降低了初学者的门槛，一方面方便了高级用户的使用。对比 python2 和 python3，升级的不兼容让很多人一直停留在 python2)</p>
<h2 id="Method-References"><a href="#Method-References" class="headerlink" title="Method References"></a>Method References</h2><p>能不能再简洁一点？有的时候我们所要做的事情不过是调用其他类中方法来处理事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure>
<p>如果这样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnAction(System.out::println);</span><br></pre></td></tr></table></figure>
<p>表达式 <code>System.out::println</code> 属于一个方法引用（method reference）， 相当于 lambda 表达式 <code>x -&gt; System.out.println(x)</code></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1flzgwjw3krj30jg0jgmxy.jpg" alt="http://harchiko.qiniudn.com/20151220232425_nWH23.jpeg"></p>
<p>再举个例子，如果你想对字符串不管大小写进行排序, 就可以这样写！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings, String::compareToIgnoreCase)</span><br></pre></td></tr></table></figure>
<p>如上所见 <code>::</code>操作符将方法名与实例或者类分隔开。总体来说，又如下的规则:</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>值得指出的是， <code>this</code>和 <code>super</code> 关键字可以在其中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, world!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentGreeter</span> <span class="keyword">extends</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(<span class="keyword">super</span>::greet);</span><br><span class="line">    t.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法引用 -Constructor-References"><a href="# 构造方法引用 -Constructor-References" class="headerlink" title="构造方法引用 Constructor References"></a>构造方法引用 Constructor References</h2><p>跟上一个差不多，毕竟 <strong> 构造方法</strong> 也是方法啊！！不过方法名字为 new 。</p>
<p>但是！这个构造方法引用有一个牛逼的地方！</p>
<p>你知道 Array 是不能使用范型的对吧！（什么，你不知道？看看这里 <a href="http://stackoverflow.com/questions/2927391/whats-the-reason-i-cant-create-generic-array-types-in-java" target="_blank" rel="noopener">http://stackoverflow.com/questions/2927391/whats-the-reason-i-cant-create-generic-array-types-in-java</a>), 你没有办法创建一个类型为 T 的 Array 。 new T[n] 将会被覆盖为 new Object[n]。</p>
<p>假设我们想要一个包含 buttons 的 Array。Stream interface 可以返回一个 Object array。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] buttons = stream.toArray();</span><br></pre></td></tr></table></figure>
<p>不不不，我们可不想要 Object。Stream 库使用 构造方法引用解决了这个问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button[] buttons = stream.toArray(Button[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1flzgwugxczj31kw0ngk5w.jpg" alt="http://harchiko.qiniudn.com/Screen%20Shot%202016-11-16%20at%204.30.23%20AM.png"></p>
<h2 id="变量作用域"><a href="# 变量作用域" class="headerlink" title="变量作用域"></a>变量作用域 </h2><p> 注意到我们在题目中写着 闭包（closure), 实际上，闭包的定义是: 引用了自由变量的函数。</p>
<p>在之前，如果需要在匿名类的内部引用外部变量，需要将外部变量定义为 final ，现在有了 lambda 表达式，你不必再这么做了。但同样需要保证外部的自由变量不能在 lambda 表达式中被改变。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1flzgwwa5lvj31kw0ngk5w.jpg" alt="http://harchiko.qiniudn.com/56cabf5d7d6dc247.jpg!600x600.jpg"><br>这是什么意思呢？ 不需要定义为 final，也不能改？</p>
<p>其实理解起来很简单，Java 8 中，不需要定义为 final ，但你其实可以直接把他当作 final，不要试图修改它就行了。</p>
<p>即便你用内部类，现在也无需定义为 final 了。</p>
<p>参考 StackOverFlow 链接: <a href="http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class" target="_blank" rel="noopener">http://stackoverflow.com/questions/4732544/why-are-only-final-variables-accessible-in-anonymous-class</a></p>
<h2 id="Default-Methods"><a href="#Default-Methods" class="headerlink" title="Default Methods"></a>Default Methods</h2><p>由于历史原因，像是类似 Collection 这种接口，如果进行添加接口的话，那将会造成之前的代码出错。</p>
<p>Java 想了一个一劳永逸的方法解决这个问题， 使用 default 修饰符来提供默认的实现</p>
<p>比如 Collection  接口的源代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有 override remove 这个方法是，调用的时候返回 UnsupportedOperationException 错误。</p>
<h2 id="Static-Methods-in-Interfaces"><a href="#Static-Methods-in-Interfaces" class="headerlink" title="Static Methods in Interfaces"></a>Static Methods in Interfaces</h2><p>Java 8 中，你可以在接口中添加静态方法了。 看起来好像并不符合接口的定义了。</p>
<p>一般用来生成一个简单实现该 interface 的实例。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://jcp.org/en/jsr/detail?id=335" target="_blank" rel="noopener">JSR 335: Lambda Expressions for the JavaTM Programming Language</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/" target="_blank" rel="noopener">Java 8 新特性概述</a></li>
<li><a href="http://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764?pgno=1" target="_blank" rel="noopener">Lambda Expressions in Java 8</a></li>
</ol>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1flzgx8edw8j31471kuhdt.jpg" alt="http://harchiko.qiniudn.com/44577950_p0.jpg"></p>
      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://blog.zhaochunqi.com">Alex Zhao</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://blog.zhaochunqi.com/2016/11/15/java_lambda_expressions/">http://blog.zhaochunqi.com/2016/11/15/java_lambda_expressions/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/java/">java</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/12/14/php-learning-materials/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">PHP 学习资料</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/10/18/dynamic_start_activity_on_android/">
        <span class="next-text nav-default">如何动态选择 Android 需要启动的 Activity</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:zcq.qiqi@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/zhaochunqi" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://weibo.com/zhaocqq" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Alex Zhao</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">var disqus_config=function(){this.page.url="http://blog.zhaochunqi.com/2016/11/15/java_lambda_expressions/",this.page.identifier="2016/11/15/java_lambda_expressions/",this.page.title="Java Lambda 表达式（又名闭包 (Closure)/ 匿名函数 ) 笔记"};!function(){var a=document,e=a.createElement("script");e.src="//blog-zhaochunqi.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(a.head||a.body).appendChild(e)}()</script>




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script></body></html>